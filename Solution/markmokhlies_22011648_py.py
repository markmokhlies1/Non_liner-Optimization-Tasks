# -*- coding: utf-8 -*-
"""MarkMokhlies_22011648.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RzEObw-sMVI4y9MFqyjsUURYKNSlvhGn
"""

import sympy as sp

def Unconstrained_Optimizer(fn, n_vars=1, minimize=True):


    symvars = [sp.Symbol(f'x_{i}', real=True) for i in range(n_vars)]

    fun = sp.sympify(fn)

    grad = [sp.diff(fun, var) for var in vars]

    critical_points = sp.solve(grad, symvars, dict=True)

    best_point = None
    best_value = None

    for point in critical_points:
        val = float(fun.subs(point))

        H = sp.hessian(fun, symvars)
        eigenvals = [ev.evalf() for ev in H.subs(point).eigenvals().keys()]

        if all(ev > 0 for ev in eigenvals):
            point_type = "min"
        elif all(ev < 0 for ev in eigenvals):
            point_type = "max"
        else:
            point_type = "saddle"

        if minimize and point_type == "min":
            if best_value is None or val < best_value:
                best_value = val
                best_point = tuple(round(float(point[v]), 4) for v in symvars)
        elif not minimize and point_type == "max":
            if best_value is None or val > best_value:
                best_value = val
                best_point = tuple(round(float(point[v]), 4) for v in symvars)

    if best_point is None:
        return None, None

    return best_point, round(best_value, 4)