# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16YHB4JyBoOAIX430R2wboagFahfG6mCL
"""

import sympy as sp # Don't import anymore libraries

def Unconstrained_Optimizer(fn, n_vars=1, minimize=True):

    var_names = [f"x_{i}" for i in range(n_vars)]
    symbols = sp.symbols(" ".join(var_names))
    if n_vars == 1:
        symbols = (symbols,)

    local_map = {name: sym for name, sym in zip(var_names, symbols)}
    f_expr = sp.sympify(fn, locals=local_map)

    f_to_opt = f_expr if minimize else -f_expr

    grads = [sp.diff(f_to_opt, s) for s in symbols]

    sols = []
    try:
        sols = sp.solve(grads, list(symbols), dict=True)
    except Exception:
        try:
            if n_vars == 1:
                sol_list = sp.solve(sp.Eq(grads[0], 0), symbols[0])
                if sol_list:
                    sols = [{symbols[0]: sol_list[0]}]
        except Exception:
            sols = []

    if not sols:
        if n_vars == 1:
            alt = sp.solve(sp.Eq(grads[0], 0), symbols[0])
            if alt:
                sols = [{symbols[0]: alt[0]}]

    if not sols:
        best_point = [None] * n_vars
        best_value = None
        return best_point, best_value

    sol = sols[0]
    if not isinstance(sol, dict):
        if isinstance(sol, (list, tuple)):
            sol = {symbols[i]: sol[i] for i in range(len(sol))}
        else:
            sol = {symbols[0]: sol}

    point_vals = []
    for s in symbols:
        val = sol.get(s, None)
        if val is None:
            point_vals.append(None)
        else:
            try:
                num = float(sp.N(val, 15))
            except Exception:
                num = float(val.evalf())
            point_vals.append(num)

    subs_map = {s: sp.nsimplify(v) if v is not None else v for s, v in zip(symbols, point_vals)}
    eval_map = {}
    for s in symbols:
        v = subs_map.get(s, None)
        if v is None:
            eval_map[s] = None
        else:
            eval_map[s] = v

    try:
        raw_value = f_expr.subs(eval_map)
        best_value_num = float(sp.N(raw_value, 15))
    except Exception:
        best_value_num = None

    def safe_round(x):
        if x is None:
            return None
        return float(round(x, 4))

    best_point = [safe_round(v) for v in point_vals]
    best_value = safe_round(best_value_num)

    return best_point, best_value

import sympy as sp

def Lagrange_Equality(obj_fn, constraints, n_vars=1, minimize=True):

    x = sp.symbols(' '.join([f'x_{i}' for i in range(n_vars)]), seq=True)

    lambdas = sp.symbols(' '.join([f'lambda_{i}' for i in range(len(constraints))]), seq=True)

    f = sp.sympify(obj_fn)
    g = [sp.sympify(c) for c in constraints]

    L = f
    for i in range(len(g)):
        L += lambdas[i] * g[i]

    eqs = [sp.diff(L, var) for var in x] + g

    sol = sp.solve(eqs, list(x) + list(lambdas), dict=True)

    results = []
    for s in sol:
        try:
            val = float(f.subs({var: s[var] for var in x}))
            point = [float(s[var]) for var in x]
            results.append((point, val))
        except Exception:
            pass

    if minimize:
        best_point, best_value = min(results, key=lambda t: t[1])
    else:
        best_point, best_value = max(results, key=lambda t: t[1])

    best_point = [round(v, 4) for v in best_point]
    best_value = round(best_value, 4)
    return (best_point, best_value)

import numpy as np
import sympy as sp

def Newton(obj_fn, initial_guess, n_vars=1, epsilon=0.001):

    var_names = [f"x_{i}" for i in range(n_vars)]
    vars = sp.symbols(" ".join(var_names))

    if n_vars == 1:
        vars = (vars,)

    loc = {var_names[i]: vars[i] for i in range(n_vars)}
    f = sp.sympify(obj_fn, locals=loc)

    grad = [sp.diff(f, v) for v in vars]

    H = [[sp.diff(grad[i], vars[j]) for j in range(n_vars)] for i in range(n_vars)]

    grad_func = sp.lambdify(vars, grad, "numpy")
    hess_func = sp.lambdify(vars, H, "numpy")
    f_func = sp.lambdify(vars, f, "numpy")

    x_old = np.array(initial_guess, dtype=float)

    while True:
        g = np.array(grad_func(*x_old), dtype=float)
        H_val = np.array(hess_func(*x_old), dtype=float)

        try:
            p = np.linalg.solve(H_val, -g)
        except np.linalg.LinAlgError:
            break

        x_new = x_old + p

        if np.linalg.norm(x_new - x_old) < epsilon:
            x_old = x_new
            break

        x_old = x_new

    best_point = [round(float(x), 4) for x in x_old]
    best_value = round(float(f_func(*x_old)), 4)

    return best_point, best_value

import sympy as sp
import numpy as np

def Steepest(obj_fn, initial_guess, n_vars=1, descent=True, epochs=10):

    var_names = [f"x_{i}" for i in range(n_vars)]
    vars = sp.symbols(" ".join(var_names))
    if n_vars == 1:
        vars = (vars,)

    local_map = {var_names[i]: vars[i] for i in range(n_vars)}
    f = sp.sympify(obj_fn, locals=local_map)


    grad = [sp.diff(f, v) for v in vars]
    grad_func = sp.lambdify(vars, grad, "numpy")
    f_func = sp.lambdify(vars, f, "numpy")


    x = np.array(initial_guess, dtype=float)

    for _ in range(epochs):
        g = np.array(grad_func(*x), dtype=float)
        if not descent:
            g = -g

        alpha = 1.0
        x_sym = sp.symbols("alpha")
        new_vars = [x[i] + x_sym * (-g[i]) for i in range(n_vars)]
        f_alpha = f.subs({vars[i]: new_vars[i] for i in range(n_vars)})
        f_alpha_func = sp.lambdify(x_sym, f_alpha, "numpy")

        df_alpha = sp.diff(f_alpha, x_sym)
        df_alpha_func = sp.lambdify(x_sym, df_alpha, "numpy")

        alpha_val = 1.0
        for _ in range(5):
            d_val = df_alpha_func(alpha_val)
            dd_val = sp.N(sp.diff(df_alpha, x_sym).subs(x_sym, alpha_val))
            if dd_val == 0:
                break
            alpha_val -= d_val / dd_val


        x = x - alpha_val * g

    best_point = [round(float(xi), 4) for xi in x]
    best_value = round(float(f_func(*x)), 4)

    return best_point, best_value

import numpy as np
import sympy as sp


def Unconstrained_Optimizer(fn, n_vars=1, minimize=True):

    var_names = [f"x_{i}" for i in range(n_vars)]
    symbols = sp.symbols(" ".join(var_names))
    if n_vars == 1:
        symbols = (symbols,)

    local_map = {name: sym for name, sym in zip(var_names, symbols)}
    f_expr = sp.sympify(fn, locals=local_map)

    f_to_opt = f_expr if minimize else -f_expr

    grads = [sp.diff(f_to_opt, s) for s in symbols]

    sols = []
    try:
        sols = sp.solve(grads, list(symbols), dict=True)
    except Exception:
        try:
            if n_vars == 1:
                sol_list = sp.solve(sp.Eq(grads[0], 0), symbols[0])
                if sol_list:
                    sols = [{symbols[0]: sol_list[0]}]
        except Exception:
            sols = []

    if not sols:
        if n_vars == 1:
            alt = sp.solve(sp.Eq(grads[0], 0), symbols[0])
            if alt:
                sols = [{symbols[0]: alt[0]}]

    if not sols:
        best_point = [None] * n_vars
        best_value = None
        return best_point, best_value

    sol = sols[0]
    if not isinstance(sol, dict):
        if isinstance(sol, (list, tuple)):
            sol = {symbols[i]: sol[i] for i in range(len(sol))}
        else:
            sol = {symbols[0]: sol}

    point_vals = []
    for s in symbols:
        val = sol.get(s, None)
        if val is None:
            point_vals.append(None)
        else:
            try:
                num = float(sp.N(val, 15))
            except Exception:
                num = float(val.evalf())
            point_vals.append(num)

    subs_map = {s: sp.nsimplify(v) if v is not None else v for s, v in zip(symbols, point_vals)}
    eval_map = {}
    for s in symbols:
        v = subs_map.get(s, None)
        if v is None:
            eval_map[s] = None
        else:
            eval_map[s] = v

    try:
        raw_value = f_expr.subs(eval_map)
        best_value_num = float(sp.N(raw_value, 15))
    except Exception:
        best_value_num = None

    def safe_round(x):
        if x is None:
            return None
        return float(round(x, 4))

    best_point = [safe_round(v) for v in point_vals]
    best_value = safe_round(best_value_num)

    return best_point, best_value

def Lagrange_Equality(obj_fn, constraints, n_vars=1, minimize=True):
    x = sp.symbols(' '.join([f'x_{i}' for i in range(n_vars)]), seq=True)

    lambdas = sp.symbols(' '.join([f'lambda_{i}' for i in range(len(constraints))]), seq=True)

    f = sp.sympify(obj_fn)
    g = [sp.sympify(c) for c in constraints]

    L = f
    for i in range(len(g)):
        L += lambdas[i] * g[i]

    eqs = [sp.diff(L, var) for var in x] + g

    sol = sp.solve(eqs, list(x) + list(lambdas), dict=True)

    results = []
    for s in sol:
        try:
            val = float(f.subs({var: s[var] for var in x}))
            point = [float(s[var]) for var in x]
            results.append((point, val))
        except Exception:
            pass

    if minimize:
        best_point, best_value = min(results, key=lambda t: t[1])
    else:
        best_point, best_value = max(results, key=lambda t: t[1])

    best_point = [round(v, 4) for v in best_point]
    best_value = round(best_value, 4)
    return (best_point, best_value)

def Newton(obj_fn, initial_guess, n_vars=1, epsilon=0.001):
    var_names = [f"x_{i}" for i in range(n_vars)]
    vars = sp.symbols(" ".join(var_names))

    if n_vars == 1:
        vars = (vars,)

    loc = {var_names[i]: vars[i] for i in range(n_vars)}
    f = sp.sympify(obj_fn, locals=loc)

    grad = [sp.diff(f, v) for v in vars]

    H = [[sp.diff(grad[i], vars[j]) for j in range(n_vars)] for i in range(n_vars)]

    grad_func = sp.lambdify(vars, grad, "numpy")
    hess_func = sp.lambdify(vars, H, "numpy")
    f_func = sp.lambdify(vars, f, "numpy")

    x_old = np.array(initial_guess, dtype=float)

    while True:
        g = np.array(grad_func(*x_old), dtype=float)
        H_val = np.array(hess_func(*x_old), dtype=float)

        try:
            p = np.linalg.solve(H_val, -g)
        except np.linalg.LinAlgError:
            break

        x_new = x_old + p

        if np.linalg.norm(x_new - x_old) < epsilon:
            x_old = x_new
            break

        x_old = x_new

    best_point = [round(float(x), 4) for x in x_old]
    best_value = round(float(f_func(*x_old)), 4)

    return best_point, best_value


def Steepest(obj_fn, initial_guess, n_vars=1, descent=True, epochs=10):
    var_names = [f"x_{i}" for i in range(n_vars)]
    vars = sp.symbols(" ".join(var_names))
    if n_vars == 1:
        vars = (vars,)

    local_map = {var_names[i]: vars[i] for i in range(n_vars)}
    f = sp.sympify(obj_fn, locals=local_map)


    grad = [sp.diff(f, v) for v in vars]
    grad_func = sp.lambdify(vars, grad, "numpy")
    f_func = sp.lambdify(vars, f, "numpy")


    x = np.array(initial_guess, dtype=float)

    for _ in range(epochs):
        g = np.array(grad_func(*x), dtype=float)
        if not descent:
            g = -g

        alpha = 1.0
        x_sym = sp.symbols("alpha")
        new_vars = [x[i] + x_sym * (-g[i]) for i in range(n_vars)]
        f_alpha = f.subs({vars[i]: new_vars[i] for i in range(n_vars)})
        f_alpha_func = sp.lambdify(x_sym, f_alpha, "numpy")

        df_alpha = sp.diff(f_alpha, x_sym)
        df_alpha_func = sp.lambdify(x_sym, df_alpha, "numpy")

        alpha_val = 1.0
        for _ in range(5):
            d_val = df_alpha_func(alpha_val)
            dd_val = sp.N(sp.diff(df_alpha, x_sym).subs(x_sym, alpha_val))
            if dd_val == 0:
                break
            alpha_val -= d_val / dd_val


        x = x - alpha_val * g

    best_point = [round(float(xi), 4) for xi in x]
    best_value = round(float(f_func(*x)), 4)

    return best_point, best_value

def optimize(obj_fn, method='calculus_based_opt', n_vars=1, minimize=True,
             constraints=None, inequality=False,
             initial_guess=None, epsilon=0.001,
             descent=True, epochs=10):

    if method == 'calculus_based_opt':
        best_point, best_value = Unconstrained_Optimizer(
            fn=obj_fn,
            n_vars=n_vars,
            minimize=minimize
        )

    elif method == 'lagrange':
        if inequality:
            raise NotImplementedError("Lagrange method for this assignment only supports equality constraints.")
        if not constraints:
             raise ValueError("Lagrange method requires 'constraints' to be provided.")

        best_point, best_value = Lagrange_Equality(
            obj_fn=obj_fn,
            constraints=constraints,
            n_vars=n_vars,
            minimize=minimize
        )

    elif method == 'newton':
        if initial_guess is None:
            raise ValueError("Newton's method requires an 'initial_guess'.")

        best_point, best_value = Newton(
            obj_fn=obj_fn,
            initial_guess=initial_guess,
            n_vars=n_vars,
            epsilon=epsilon
        )

    elif method == 'steepest':
        if initial_guess is None:
            raise ValueError("Steepest method requires an 'initial_guess'.")

        best_point, best_value = Steepest(
            obj_fn=obj_fn,
            initial_guess=initial_guess,
            n_vars=n_vars,
            descent=descent,
            epochs=epochs
        )

    else:
        best_point = [None] * n_vars
        best_value = None

    return (best_point, best_value)