# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bX2nCf7lo1JYCgC8SaD1Opcs84ktrIso
"""

import sympy as sp

def Lagrange_Equality(obj_fn, constraints, n_vars=1, minimize=True):

    x = sp.symbols(' '.join([f'x_{i}' for i in range(n_vars)]), seq=True)

    lambdas = sp.symbols(' '.join([f'lambda_{i}' for i in range(len(constraints))]), seq=True)

    f = sp.sympify(obj_fn)
    g = [sp.sympify(c) for c in constraints]

    L = f
    for i in range(len(g)):
        L += lambdas[i] * g[i]

    eqs = [sp.diff(L, var) for var in x] + g

    sol = sp.solve(eqs, list(x) + list(lambdas), dict=True)

    results = []
    for s in sol:
        try:
            val = float(f.subs({var: s[var] for var in x}))
            point = [float(s[var]) for var in x]
            results.append((point, val))
        except Exception:
            pass

    if minimize:
        best_point, best_value = min(results, key=lambda t: t[1])
    else:
        best_point, best_value = max(results, key=lambda t: t[1])

    best_point = [round(v, 4) for v in best_point]
    best_value = round(best_value, 4)
    return (best_point, best_value)